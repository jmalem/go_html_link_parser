<!DOCTYPE html>
<html lang="en">
<meta charset="utf-8">
<meta name="description" content="Go is an open source programming language that makes it easy to build simple, reliable, and efficient software.">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="theme-color" content="#00ADD8">

  <title>bufio - The Go Programming Language</title>

<link href="https://fonts.googleapis.com/css?family=Work+Sans:600|Roboto:400,700" rel="stylesheet">
<link href="https://fonts.googleapis.com/css?family=Product+Sans&text=Supported%20by%20Google&display=swap" rel="stylesheet">
<link type="text/css" rel="stylesheet" href="/lib/godoc/style.css">
<script>window.initFuncs = [];</script>

<script>
var _gaq = _gaq || [];
_gaq.push(["_setAccount", "UA-11222381-2"]);
window.trackPageview = function() {
  _gaq.push(["_trackPageview", location.pathname+location.hash]);
};
window.trackPageview();
window.trackEvent = function(category, action, opt_label, opt_value, opt_noninteraction) {
  _gaq.push(["_trackEvent", category, action, opt_label, opt_value, opt_noninteraction]);
};
</script>

<script src="/lib/godoc/jquery.js" defer></script>

<script src="/lib/godoc/playground.js" defer></script>
<script>var goVersion = "go1.16.3";</script>
<script src="/lib/godoc/godocs.js" defer></script>

<body class="Site">
<header class="Header js-header">
  <div class="Header-banner">
    Black Lives Matter.
    <a href="https://support.eji.org/give/153413/#!/donation/checkout"
       target="_blank"
       rel="noopener">Support the Equal Justice Initiative.</a>
  </div>
  <nav class="Header-nav Header-nav--wide">
    <a href="/"><img class="Header-logo" src="/lib/godoc/images/go-logo-blue.svg" alt="Go"></a>
    <button class="Header-menuButton js-headerMenuButton" aria-label="Main menu" aria-expanded="false">
      <div class="Header-menuButtonInner"></div>
    </button>
    <ul class="Header-menu">
      <li class="Header-menuItem"><a href="/doc/">Documents</a></li>
      <li class="Header-menuItem"><a href="/pkg/">Packages</a></li>
      <li class="Header-menuItem"><a href="/project/">The Project</a></li>
      <li class="Header-menuItem"><a href="/help/">Help</a></li>
      
        <li class="Header-menuItem"><a href="/blog/">Blog</a></li>
        <li class="Header-menuItem"><a href="https://play.golang.org/">Play</a></li>
      
    </ul>
  </nav>
</header>

<main id="page" class="Site-content wide">
<div class="container">


  <h1>
    Package bufio
    <span class="text-muted"></span>
  </h1>







<div id="nav"></div>


<!--
	Copyright 2009 The Go Authors. All rights reserved.
	Use of this source code is governed by a BSD-style
	license that can be found in the LICENSE file.
-->
<!--
	Note: Static (i.e., not template-generated) href and id
	attributes start with "pkg-" to make it impossible for
	them to conflict with generated attributes (some of which
	correspond to Go identifiers).
-->

	
		
		<div id="short-nav">
			<dl>
			<dd><code>import "bufio"</code></dd>
			</dl>
			<dl>
			<dd><a href="#pkg-overview" class="overviewLink">Overview</a></dd>
			<dd><a href="#pkg-index" class="indexLink">Index</a></dd>
			
				<dd><a href="#pkg-examples" class="examplesLink">Examples</a></dd>
			
			
			</dl>
		</div>
		<!-- The package's Name is printed as title by the top-level template -->
		<div id="pkg-overview" class="toggleVisible">
			<div class="collapsed">
				<h2 class="toggleButton" title="Click to show Overview section">Overview ▹</h2>
			</div>
			<div class="expanded">
				<h2 class="toggleButton" title="Click to hide Overview section">Overview ▾</h2>
				<p>
Package bufio implements buffered I/O. It wraps an io.Reader or io.Writer
object, creating another object (Reader or Writer) that also implements
the interface but provides buffering and some help for textual I/O.
</p>

				
			</div>
		</div>

		<div id="pkg-index" class="toggleVisible">
		<div class="collapsed">
			<h2 class="toggleButton" title="Click to show Index section">Index ▹</h2>
		</div>
		<div class="expanded">
			<h2 class="toggleButton" title="Click to hide Index section">Index ▾</h2>

		<!-- Table of contents for API; must be named manual-nav to turn off auto nav. -->
			<div id="manual-nav">
			<dl>
			
				<dd><a href="#pkg-constants">Constants</a></dd>
			
			
				<dd><a href="#pkg-variables">Variables</a></dd>
			
			
				
				<dd><a href="#ScanBytes">func ScanBytes(data []byte, atEOF bool) (advance int, token []byte, err error)</a></dd>
			
				
				<dd><a href="#ScanLines">func ScanLines(data []byte, atEOF bool) (advance int, token []byte, err error)</a></dd>
			
				
				<dd><a href="#ScanRunes">func ScanRunes(data []byte, atEOF bool) (advance int, token []byte, err error)</a></dd>
			
				
				<dd><a href="#ScanWords">func ScanWords(data []byte, atEOF bool) (advance int, token []byte, err error)</a></dd>
			
			
				
				<dd><a href="#ReadWriter">type ReadWriter</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewReadWriter">func NewReadWriter(r *Reader, w *Writer) *ReadWriter</a></dd>
				
				
			
				
				<dd><a href="#Reader">type Reader</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewReader">func NewReader(rd io.Reader) *Reader</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewReaderSize">func NewReaderSize(rd io.Reader, size int) *Reader</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Reader.Buffered">func (b *Reader) Buffered() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Reader.Discard">func (b *Reader) Discard(n int) (discarded int, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Reader.Peek">func (b *Reader) Peek(n int) ([]byte, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Reader.Read">func (b *Reader) Read(p []byte) (n int, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Reader.ReadByte">func (b *Reader) ReadByte() (byte, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Reader.ReadBytes">func (b *Reader) ReadBytes(delim byte) ([]byte, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Reader.ReadLine">func (b *Reader) ReadLine() (line []byte, isPrefix bool, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Reader.ReadRune">func (b *Reader) ReadRune() (r rune, size int, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Reader.ReadSlice">func (b *Reader) ReadSlice(delim byte) (line []byte, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Reader.ReadString">func (b *Reader) ReadString(delim byte) (string, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Reader.Reset">func (b *Reader) Reset(r io.Reader)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Reader.Size">func (b *Reader) Size() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Reader.UnreadByte">func (b *Reader) UnreadByte() error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Reader.UnreadRune">func (b *Reader) UnreadRune() error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Reader.WriteTo">func (b *Reader) WriteTo(w io.Writer) (n int64, err error)</a></dd>
				
			
				
				<dd><a href="#Scanner">type Scanner</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewScanner">func NewScanner(r io.Reader) *Scanner</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Scanner.Buffer">func (s *Scanner) Buffer(buf []byte, max int)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Scanner.Bytes">func (s *Scanner) Bytes() []byte</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Scanner.Err">func (s *Scanner) Err() error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Scanner.Scan">func (s *Scanner) Scan() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Scanner.Split">func (s *Scanner) Split(split SplitFunc)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Scanner.Text">func (s *Scanner) Text() string</a></dd>
				
			
				
				<dd><a href="#SplitFunc">type SplitFunc</a></dd>
				
				
			
				
				<dd><a href="#Writer">type Writer</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewWriter">func NewWriter(w io.Writer) *Writer</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewWriterSize">func NewWriterSize(w io.Writer, size int) *Writer</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Writer.Available">func (b *Writer) Available() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Writer.Buffered">func (b *Writer) Buffered() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Writer.Flush">func (b *Writer) Flush() error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Writer.ReadFrom">func (b *Writer) ReadFrom(r io.Reader) (n int64, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Writer.Reset">func (b *Writer) Reset(w io.Writer)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Writer.Size">func (b *Writer) Size() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Writer.Write">func (b *Writer) Write(p []byte) (nn int, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Writer.WriteByte">func (b *Writer) WriteByte(c byte) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Writer.WriteRune">func (b *Writer) WriteRune(r rune) (size int, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Writer.WriteString">func (b *Writer) WriteString(s string) (int, error)</a></dd>
				
			
			
			</dl>
			</div><!-- #manual-nav -->

		
		<div id="pkg-examples">
			<h3>Examples</h3>
			<div class="js-expandAll expandAll collapsed">(Expand All)</div>
			<dl>
			
			<dd><a class="exampleLink" href="#example_Scanner_Bytes">Scanner.Bytes</a></dd>
			
			<dd><a class="exampleLink" href="#example_Scanner_custom">Scanner (Custom)</a></dd>
			
			<dd><a class="exampleLink" href="#example_Scanner_emptyFinalToken">Scanner (EmptyFinalToken)</a></dd>
			
			<dd><a class="exampleLink" href="#example_Scanner_lines">Scanner (Lines)</a></dd>
			
			<dd><a class="exampleLink" href="#example_Scanner_words">Scanner (Words)</a></dd>
			
			<dd><a class="exampleLink" href="#example_Writer">Writer</a></dd>
			
			</dl>
		</div>
		

		
			<h3>Package files</h3>
			<p>
			<span style="font-size:90%">
			
				<a href="/src/bufio/bufio.go">bufio.go</a>
			
				<a href="/src/bufio/scan.go">scan.go</a>
			
			</span>
			</p>
		
		</div><!-- .expanded -->
		</div><!-- #pkg-index -->

		
			<h2 id="pkg-constants">Constants</h2>
			
				
				<pre>const (
    <span class="comment">// MaxScanTokenSize is the maximum size used to buffer a token</span>
    <span class="comment">// unless the user provides an explicit buffer with Scanner.Buffer.</span>
    <span class="comment">// The actual maximum token size may be smaller as the buffer</span>
    <span class="comment">// may need to include, for instance, a newline.</span>
    <span id="MaxScanTokenSize">MaxScanTokenSize</span> = 64 * 1024
)</pre>
			
		
		
			<h2 id="pkg-variables">Variables</h2>
			
				
				<pre>var (
    <span id="ErrInvalidUnreadByte">ErrInvalidUnreadByte</span> = <a href="/pkg/errors/">errors</a>.<a href="/pkg/errors/#New">New</a>(&#34;bufio: invalid use of UnreadByte&#34;)
    <span id="ErrInvalidUnreadRune">ErrInvalidUnreadRune</span> = <a href="/pkg/errors/">errors</a>.<a href="/pkg/errors/#New">New</a>(&#34;bufio: invalid use of UnreadRune&#34;)
    <span id="ErrBufferFull">ErrBufferFull</span>        = <a href="/pkg/errors/">errors</a>.<a href="/pkg/errors/#New">New</a>(&#34;bufio: buffer full&#34;)
    <span id="ErrNegativeCount">ErrNegativeCount</span>     = <a href="/pkg/errors/">errors</a>.<a href="/pkg/errors/#New">New</a>(&#34;bufio: negative count&#34;)
)</pre>
			
				<p>
Errors returned by Scanner.
</p>

				<pre>var (
    <span id="ErrTooLong">ErrTooLong</span>         = <a href="/pkg/errors/">errors</a>.<a href="/pkg/errors/#New">New</a>(&#34;bufio.Scanner: token too long&#34;)
    <span id="ErrNegativeAdvance">ErrNegativeAdvance</span> = <a href="/pkg/errors/">errors</a>.<a href="/pkg/errors/#New">New</a>(&#34;bufio.Scanner: SplitFunc returns negative advance count&#34;)
    <span id="ErrAdvanceTooFar">ErrAdvanceTooFar</span>   = <a href="/pkg/errors/">errors</a>.<a href="/pkg/errors/#New">New</a>(&#34;bufio.Scanner: SplitFunc returns advance count beyond input&#34;)
    <span id="ErrBadReadCount">ErrBadReadCount</span>    = <a href="/pkg/errors/">errors</a>.<a href="/pkg/errors/#New">New</a>(&#34;bufio.Scanner: Read returned impossible count&#34;)
)</pre>
			
				<p>
ErrFinalToken is a special sentinel error value. It is intended to be
returned by a Split function to indicate that the token being delivered
with the error is the last token and scanning should stop after this one.
After ErrFinalToken is received by Scan, scanning stops with no error.
The value is useful to stop processing early or when it is necessary to
deliver a final empty token. One could achieve the same behavior
with a custom error value but providing one here is tidier.
See the emptyFinalToken example for a use of this value.
</p>

				<pre>var <span id="ErrFinalToken">ErrFinalToken</span> = <a href="/pkg/errors/">errors</a>.<a href="/pkg/errors/#New">New</a>(&#34;final token&#34;)</pre>
			
		
		
			
			
			<h2 id="ScanBytes">func <a href="/src/bufio/scan.go?s=9761:9839#L279">ScanBytes</a>
				<a class="permalink" href="#ScanBytes">&#xb6;</a>
				
				<span title="Added in Go 1.1">1.1</span>
			</h2>
			<pre>func ScanBytes(data []<a href="/pkg/builtin/#byte">byte</a>, atEOF <a href="/pkg/builtin/#bool">bool</a>) (advance <a href="/pkg/builtin/#int">int</a>, token []<a href="/pkg/builtin/#byte">byte</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
			<p>
ScanBytes is a split function for a Scanner that returns each byte as a token.
</p>

			

		
			
			
			<h2 id="ScanLines">func <a href="/src/bufio/scan.go?s=11967:12045#L340">ScanLines</a>
				<a class="permalink" href="#ScanLines">&#xb6;</a>
				
				<span title="Added in Go 1.1">1.1</span>
			</h2>
			<pre>func ScanLines(data []<a href="/pkg/builtin/#byte">byte</a>, atEOF <a href="/pkg/builtin/#bool">bool</a>) (advance <a href="/pkg/builtin/#int">int</a>, token []<a href="/pkg/builtin/#byte">byte</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
			<p>
ScanLines is a split function for a Scanner that returns each line of
text, stripped of any trailing end-of-line marker. The returned line may
be empty. The end-of-line marker is one optional carriage return followed
by one mandatory newline. In regular expression notation, it is `\r?\n`.
The last non-empty line of input will be returned even if it has no
newline.
</p>

			

		
			
			
			<h2 id="ScanRunes">func <a href="/src/bufio/scan.go?s=10408:10486#L294">ScanRunes</a>
				<a class="permalink" href="#ScanRunes">&#xb6;</a>
				
				<span title="Added in Go 1.1">1.1</span>
			</h2>
			<pre>func ScanRunes(data []<a href="/pkg/builtin/#byte">byte</a>, atEOF <a href="/pkg/builtin/#bool">bool</a>) (advance <a href="/pkg/builtin/#int">int</a>, token []<a href="/pkg/builtin/#byte">byte</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
			<p>
ScanRunes is a split function for a Scanner that returns each
UTF-8-encoded rune as a token. The sequence of runes returned is
equivalent to that from a range loop over the input as a string, which
means that erroneous UTF-8 encodings translate to U+FFFD = &#34;\xef\xbf\xbd&#34;.
Because of the Scan interface, this makes it impossible for the client to
distinguish correctly encoded replacement runes from encoding errors.
</p>

			

		
			
			
			<h2 id="ScanWords">func <a href="/src/bufio/scan.go?s=13261:13339#L385">ScanWords</a>
				<a class="permalink" href="#ScanWords">&#xb6;</a>
				
				<span title="Added in Go 1.1">1.1</span>
			</h2>
			<pre>func ScanWords(data []<a href="/pkg/builtin/#byte">byte</a>, atEOF <a href="/pkg/builtin/#bool">bool</a>) (advance <a href="/pkg/builtin/#int">int</a>, token []<a href="/pkg/builtin/#byte">byte</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
			<p>
ScanWords is a split function for a Scanner that returns each
space-separated word of text, with surrounding spaces deleted. It will
never return an empty string. The definition of space is set by
unicode.IsSpace.
</p>

			

		
		
			
			
			<h2 id="ReadWriter">type <a href="/src/bufio/bufio.go?s=19622:19666#L764">ReadWriter</a>
				<a class="permalink" href="#ReadWriter">&#xb6;</a>
				
				
			</h2>
			<p>
ReadWriter stores pointers to a Reader and a Writer.
It implements io.ReadWriter.
</p>

			<pre>type ReadWriter struct {
    *<a href="#Reader">Reader</a>
    *<a href="#Writer">Writer</a>
}
</pre>

			

			

			

			
				
				<h3 id="NewReadWriter">func <a href="/src/bufio/bufio.go?s=19740:19792#L770">NewReadWriter</a>
					<a class="permalink" href="#NewReadWriter">&#xb6;</a>
					
					
				</h3>
				<pre>func NewReadWriter(r *<a href="#Reader">Reader</a>, w *<a href="#Writer">Writer</a>) *<a href="#ReadWriter">ReadWriter</a></pre>
				<p>
NewReadWriter allocates a new ReadWriter that dispatches to r and w.
</p>

				
			

			
		
			
			
			<h2 id="Reader">type <a href="/src/bufio/bufio.go?s=840:1162#L22">Reader</a>
				<a class="permalink" href="#Reader">&#xb6;</a>
				
				
			</h2>
			<p>
Reader implements buffering for an io.Reader object.
</p>

			<pre>type Reader struct {
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			

			
				
				<h3 id="NewReader">func <a href="/src/bufio/bufio.go?s=1768:1804#L52">NewReader</a>
					<a class="permalink" href="#NewReader">&#xb6;</a>
					
					
				</h3>
				<pre>func NewReader(rd <a href="/pkg/io/">io</a>.<a href="/pkg/io/#Reader">Reader</a>) *<a href="#Reader">Reader</a></pre>
				<p>
NewReader returns a new Reader whose buffer has the default size.
</p>

				
			
				
				<h3 id="NewReaderSize">func <a href="/src/bufio/bufio.go?s=1425:1475#L37">NewReaderSize</a>
					<a class="permalink" href="#NewReaderSize">&#xb6;</a>
					
					
				</h3>
				<pre>func NewReaderSize(rd <a href="/pkg/io/">io</a>.<a href="/pkg/io/#Reader">Reader</a>, size <a href="/pkg/builtin/#int">int</a>) *<a href="#Reader">Reader</a></pre>
				<p>
NewReaderSize returns a new Reader whose buffer has at least the specified
size. If the argument io.Reader is already a Reader with large enough
size, it returns the underlying Reader.
</p>

				
			

			
				
				<h3 id="Reader.Buffered">func (*Reader) <a href="/src/bufio/bufio.go?s=7807:7838#L309">Buffered</a>
					<a class="permalink" href="#Reader.Buffered">&#xb6;</a>
					
					
				</h3>
				<pre>func (b *<a href="#Reader">Reader</a>) Buffered() <a href="/pkg/builtin/#int">int</a></pre>
				<p>
Buffered returns the number of bytes that can be read from the current buffer.
</p>

				
				
			
				
				<h3 id="Reader.Discard">func (*Reader) <a href="/src/bufio/bufio.go?s=4174:4232#L154">Discard</a>
					<a class="permalink" href="#Reader.Discard">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (b *<a href="#Reader">Reader</a>) Discard(n <a href="/pkg/builtin/#int">int</a>) (discarded <a href="/pkg/builtin/#int">int</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
Discard skips the next n bytes, returning the number of bytes discarded.
</p>
<p>
If Discard skips fewer than n bytes, it also returns an error.
If 0 &lt;= n &lt;= b.Buffered(), Discard is guaranteed to succeed without
reading from the underlying io.Reader.
</p>

				
				
			
				
				<h3 id="Reader.Peek">func (*Reader) <a href="/src/bufio/bufio.go?s=3377:3421#L120">Peek</a>
					<a class="permalink" href="#Reader.Peek">&#xb6;</a>
					
					
				</h3>
				<pre>func (b *<a href="#Reader">Reader</a>) Peek(n <a href="/pkg/builtin/#int">int</a>) ([]<a href="/pkg/builtin/#byte">byte</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
Peek returns the next n bytes without advancing the reader. The bytes stop
being valid at the next read call. If Peek returns fewer than n bytes, it
also returns an error explaining why the read is short. The error is
ErrBufferFull if n is larger than b&#39;s buffer size.
</p>
<p>
Calling Peek prevents a UnreadByte or UnreadRune call from succeeding
until the next read operation.
</p>

				
				
			
				
				<h3 id="Reader.Read">func (*Reader) <a href="/src/bufio/bufio.go?s=4875:4925#L188">Read</a>
					<a class="permalink" href="#Reader.Read">&#xb6;</a>
					
					
				</h3>
				<pre>func (b *<a href="#Reader">Reader</a>) Read(p []<a href="/pkg/builtin/#byte">byte</a>) (n <a href="/pkg/builtin/#int">int</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
Read reads data into p.
It returns the number of bytes read into p.
The bytes are taken from at most one Read on the underlying Reader,
hence n may be less than len(p).
To read exactly len(p) bytes, use io.ReadFull(b, p).
At EOF, the count will be zero and err will be io.EOF.
</p>

				
				
			
				
				<h3 id="Reader.ReadByte">func (*Reader) <a href="/src/bufio/bufio.go?s=5802:5843#L237">ReadByte</a>
					<a class="permalink" href="#Reader.ReadByte">&#xb6;</a>
					
					
				</h3>
				<pre>func (b *<a href="#Reader">Reader</a>) ReadByte() (<a href="/pkg/builtin/#byte">byte</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
ReadByte reads and returns a single byte.
If no byte is available, returns an error.
</p>

				
				
			
				
				<h3 id="Reader.ReadBytes">func (*Reader) <a href="/src/bufio/bufio.go?s=12388:12442#L452">ReadBytes</a>
					<a class="permalink" href="#Reader.ReadBytes">&#xb6;</a>
					
					
				</h3>
				<pre>func (b *<a href="#Reader">Reader</a>) ReadBytes(delim <a href="/pkg/builtin/#byte">byte</a>) ([]<a href="/pkg/builtin/#byte">byte</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
ReadBytes reads until the first occurrence of delim in the input,
returning a slice containing the data up to and including the delimiter.
If ReadBytes encounters an error before finding a delimiter,
it returns the data read before the error and the error itself (often io.EOF).
ReadBytes returns err != nil if and only if the returned data does not end in
delim.
For simple uses, a Scanner may be more convenient.
</p>

				
				
			
				
				<h3 id="Reader.ReadLine">func (*Reader) <a href="/src/bufio/bufio.go?s=10168:10235#L378">ReadLine</a>
					<a class="permalink" href="#Reader.ReadLine">&#xb6;</a>
					
					
				</h3>
				<pre>func (b *<a href="#Reader">Reader</a>) ReadLine() (line []<a href="/pkg/builtin/#byte">byte</a>, isPrefix <a href="/pkg/builtin/#bool">bool</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
ReadLine is a low-level line-reading primitive. Most callers should use
ReadBytes(&#39;\n&#39;) or ReadString(&#39;\n&#39;) instead or use a Scanner.
</p>
<p>
ReadLine tries to return a single line, not including the end-of-line bytes.
If the line was too long for the buffer then isPrefix is set and the
beginning of the line is returned. The rest of the line will be returned
from future calls. isPrefix will be false when returning the last fragment
of the line. The returned buffer is only valid until the next call to
ReadLine. ReadLine either returns a non-nil line or it returns an error,
never both.
</p>
<p>
The text returned from ReadLine does not include the line end (&#34;\r\n&#34; or &#34;\n&#34;).
No indication or error is given if the input ends without a final line end.
Calling UnreadByte after ReadLine will always unread the last byte read
(possibly a character belonging to the line end) even if that byte is not
part of the line returned by ReadLine.
</p>

				
				
			
				
				<h3 id="Reader.ReadRune">func (*Reader) <a href="/src/bufio/bufio.go?s=6797:6854#L276">ReadRune</a>
					<a class="permalink" href="#Reader.ReadRune">&#xb6;</a>
					
					
				</h3>
				<pre>func (b *<a href="#Reader">Reader</a>) ReadRune() (r <a href="/pkg/builtin/#rune">rune</a>, size <a href="/pkg/builtin/#int">int</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
ReadRune reads a single UTF-8 encoded Unicode character and returns the
rune and its size in bytes. If the encoded rune is invalid, it consumes one byte
and returns unicode.ReplacementChar (U+FFFD) with a size of 1.
</p>

				
				
			
				
				<h3 id="Reader.ReadSlice">func (*Reader) <a href="/src/bufio/bufio.go?s=8488:8551#L321">ReadSlice</a>
					<a class="permalink" href="#Reader.ReadSlice">&#xb6;</a>
					
					
				</h3>
				<pre>func (b *<a href="#Reader">Reader</a>) ReadSlice(delim <a href="/pkg/builtin/#byte">byte</a>) (line []<a href="/pkg/builtin/#byte">byte</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
ReadSlice reads until the first occurrence of delim in the input,
returning a slice pointing at the bytes in the buffer.
The bytes stop being valid at the next read.
If ReadSlice encounters an error before finding a delimiter,
it returns all the data in the buffer and the error itself (often io.EOF).
ReadSlice fails with error ErrBufferFull if the buffer fills without a delim.
Because the data returned from ReadSlice will be overwritten
by the next I/O operation, most clients should use
ReadBytes or ReadString instead.
ReadSlice returns err != nil if and only if line does not end in delim.
</p>

				
				
			
				
				<h3 id="Reader.ReadString">func (*Reader) <a href="/src/bufio/bufio.go?s=13166:13221#L472">ReadString</a>
					<a class="permalink" href="#Reader.ReadString">&#xb6;</a>
					
					
				</h3>
				<pre>func (b *<a href="#Reader">Reader</a>) ReadString(delim <a href="/pkg/builtin/#byte">byte</a>) (<a href="/pkg/builtin/#string">string</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
ReadString reads until the first occurrence of delim in the input,
returning a string containing the data up to and including the delimiter.
If ReadString encounters an error before finding a delimiter,
it returns the data read before the error and the error itself (often io.EOF).
ReadString returns err != nil if and only if the returned data does not end in
delim.
For simple uses, a Scanner may be more convenient.
</p>

				
				
			
				
				<h3 id="Reader.Reset">func (*Reader) <a href="/src/bufio/bufio.go?s=2070:2105#L61">Reset</a>
					<a class="permalink" href="#Reader.Reset">&#xb6;</a>
					
					<span title="Added in Go 1.2">1.2</span>
				</h3>
				<pre>func (b *<a href="#Reader">Reader</a>) Reset(r <a href="/pkg/io/">io</a>.<a href="/pkg/io/#Reader">Reader</a>)</pre>
				<p>
Reset discards any buffered data, resets all state, and switches
the buffered reader to read from r.
</p>

				
				
			
				
				<h3 id="Reader.Size">func (*Reader) <a href="/src/bufio/bufio.go?s=1912:1939#L57">Size</a>
					<a class="permalink" href="#Reader.Size">&#xb6;</a>
					
					<span title="Added in Go 1.10">1.10</span>
				</h3>
				<pre>func (b *<a href="#Reader">Reader</a>) Size() <a href="/pkg/builtin/#int">int</a></pre>
				<p>
Size returns the size of the underlying buffer in bytes.
</p>

				
				
			
				
				<h3 id="Reader.UnreadByte">func (*Reader) <a href="/src/bufio/bufio.go?s=6278:6313#L256">UnreadByte</a>
					<a class="permalink" href="#Reader.UnreadByte">&#xb6;</a>
					
					
				</h3>
				<pre>func (b *<a href="#Reader">Reader</a>) UnreadByte() <a href="/pkg/builtin/#error">error</a></pre>
				<p>
UnreadByte unreads the last byte. Only the most recently read byte can be unread.
</p>
<p>
UnreadByte returns an error if the most recent method called on the
Reader was not a read operation. Notably, Peek is not considered a
read operation.
</p>

				
				
			
				
				<h3 id="Reader.UnreadRune">func (*Reader) <a href="/src/bufio/bufio.go?s=7529:7564#L298">UnreadRune</a>
					<a class="permalink" href="#Reader.UnreadRune">&#xb6;</a>
					
					
				</h3>
				<pre>func (b *<a href="#Reader">Reader</a>) UnreadRune() <a href="/pkg/builtin/#error">error</a></pre>
				<p>
UnreadRune unreads the last rune. If the most recent method called on
the Reader was not a ReadRune, UnreadRune returns an error. (In this
regard it is stricter than UnreadByte, which will unread the last byte
from any read operation.)
</p>

				
				
			
				
				<h3 id="Reader.WriteTo">func (*Reader) <a href="/src/bufio/bufio.go?s=13732:13790#L489">WriteTo</a>
					<a class="permalink" href="#Reader.WriteTo">&#xb6;</a>
					
					<span title="Added in Go 1.1">1.1</span>
				</h3>
				<pre>func (b *<a href="#Reader">Reader</a>) WriteTo(w <a href="/pkg/io/">io</a>.<a href="/pkg/io/#Writer">Writer</a>) (n <a href="/pkg/builtin/#int64">int64</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
WriteTo implements io.WriterTo.
This may make multiple calls to the Read method of the underlying Reader.
If the underlying reader supports the WriteTo method,
this calls the underlying WriteTo without buffering.
</p>

				
				
			
		
			
			
			<h2 id="Scanner">type <a href="/src/bufio/scan.go?s=1184:1841#L20">Scanner</a>
				<a class="permalink" href="#Scanner">&#xb6;</a>
				
				<span title="Added in Go 1.1">1.1</span>
			</h2>
			<p>
Scanner provides a convenient interface for reading data such as
a file of newline-delimited lines of text. Successive calls to
the Scan method will step through the &#39;tokens&#39; of a file, skipping
the bytes between the tokens. The specification of a token is
defined by a split function of type SplitFunc; the default split
function breaks the input into lines with line termination stripped. Split
functions are defined in this package for scanning a file into
lines, bytes, UTF-8-encoded runes, and space-delimited words. The
client may instead provide a custom split function.
</p>
<p>
Scanning stops unrecoverably at EOF, the first I/O error, or a token too
large to fit in the buffer. When a scan stops, the reader may have
advanced arbitrarily far past the last token. Programs that need more
control over error handling or large tokens, or must run sequential scans
on a reader, should use bufio.Reader instead.
</p>

			<pre>type Scanner struct {
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			<div id="example_Scanner_custom" class="toggle">
  <div class="collapsed">
    <p class="exampleHeading toggleButton">▹ <span class="text">Example (Custom)</span></p>
  </div>
  <div class="expanded">
    <p class="exampleHeading toggleButton">▾ <span class="text">Example (Custom)</span></p>
    <p>Use a Scanner with a custom split function (built by wrapping ScanWords) to validate
32-bit decimal input.
</p>
    
    
      <div class="play">
        <div class="input"><textarea class="code" spellcheck="false">package main

import (
	&#34;bufio&#34;
	&#34;fmt&#34;
	&#34;strconv&#34;
	&#34;strings&#34;
)

func main() {
	// An artificial input source.
	const input = &#34;1234 5678 1234567901234567890&#34;
	scanner := bufio.NewScanner(strings.NewReader(input))
	// Create a custom split function by wrapping the existing ScanWords function.
	split := func(data []byte, atEOF bool) (advance int, token []byte, err error) {
		advance, token, err = bufio.ScanWords(data, atEOF)
		if err == nil &amp;&amp; token != nil {
			_, err = strconv.ParseInt(string(token), 10, 32)
		}
		return
	}
	// Set the split function for the scanning operation.
	scanner.Split(split)
	// Validate the input
	for scanner.Scan() {
		fmt.Printf(&#34;%s\n&#34;, scanner.Text())
	}

	if err := scanner.Err(); err != nil {
		fmt.Printf(&#34;Invalid input: %s&#34;, err)
	}
}
</textarea></div>
        <div class="output"><pre>1234
5678
Invalid input: strconv.ParseInt: parsing &#34;1234567901234567890&#34;: value out of range
</pre></div>
        <div class="buttons">
          <button class="Button Button--primary run" title="Run this code [shift-enter]">Run</button>
          <button class="Button fmt" title="Format this code">Format</button>
          
            <button class="Button share" title="Share this code">Share</button>
          
        </div>
      </div>
    
  </div>
</div>
<div id="example_Scanner_emptyFinalToken" class="toggle">
  <div class="collapsed">
    <p class="exampleHeading toggleButton">▹ <span class="text">Example (EmptyFinalToken)</span></p>
  </div>
  <div class="expanded">
    <p class="exampleHeading toggleButton">▾ <span class="text">Example (EmptyFinalToken)</span></p>
    <p>Use a Scanner with a custom split function to parse a comma-separated
list with an empty final value.
</p>
    
    
      <div class="play">
        <div class="input"><textarea class="code" spellcheck="false">package main

import (
	&#34;bufio&#34;
	&#34;fmt&#34;
	&#34;os&#34;
	&#34;strings&#34;
)

func main() {
	// Comma-separated list; last entry is empty.
	const input = &#34;1,2,3,4,&#34;
	scanner := bufio.NewScanner(strings.NewReader(input))
	// Define a split function that separates on commas.
	onComma := func(data []byte, atEOF bool) (advance int, token []byte, err error) {
		for i := 0; i &lt; len(data); i++ {
			if data[i] == &#39;,&#39; {
				return i + 1, data[:i], nil
			}
		}
		if !atEOF {
			return 0, nil, nil
		}
		// There is one final token to be delivered, which may be the empty string.
		// Returning bufio.ErrFinalToken here tells Scan there are no more tokens after this
		// but does not trigger an error to be returned from Scan itself.
		return 0, data, bufio.ErrFinalToken
	}
	scanner.Split(onComma)
	// Scan.
	for scanner.Scan() {
		fmt.Printf(&#34;%q &#34;, scanner.Text())
	}
	if err := scanner.Err(); err != nil {
		fmt.Fprintln(os.Stderr, &#34;reading input:&#34;, err)
	}
}
</textarea></div>
        <div class="output"><pre>&#34;1&#34; &#34;2&#34; &#34;3&#34; &#34;4&#34; &#34;&#34;
</pre></div>
        <div class="buttons">
          <button class="Button Button--primary run" title="Run this code [shift-enter]">Run</button>
          <button class="Button fmt" title="Format this code">Format</button>
          
            <button class="Button share" title="Share this code">Share</button>
          
        </div>
      </div>
    
  </div>
</div>
<div id="example_Scanner_lines" class="toggle">
  <div class="collapsed">
    <p class="exampleHeading toggleButton">▹ <span class="text">Example (Lines)</span></p>
  </div>
  <div class="expanded">
    <p class="exampleHeading toggleButton">▾ <span class="text">Example (Lines)</span></p>
    <p>The simplest use of a Scanner, to read standard input as a set of lines.
</p>
    
    
      <div class="play">
        <div class="input"><textarea class="code" spellcheck="false">package main

import (
	&#34;bufio&#34;
	&#34;fmt&#34;
	&#34;os&#34;
)

func main() {
	scanner := bufio.NewScanner(os.Stdin)
	for scanner.Scan() {
		fmt.Println(scanner.Text()) // Println will add back the final &#39;\n&#39;
	}
	if err := scanner.Err(); err != nil {
		fmt.Fprintln(os.Stderr, &#34;reading standard input:&#34;, err)
	}
}
</textarea></div>
        <div class="output"><pre></pre></div>
        <div class="buttons">
          <button class="Button Button--primary run" title="Run this code [shift-enter]">Run</button>
          <button class="Button fmt" title="Format this code">Format</button>
          
            <button class="Button share" title="Share this code">Share</button>
          
        </div>
      </div>
    
  </div>
</div>
<div id="example_Scanner_words" class="toggle">
  <div class="collapsed">
    <p class="exampleHeading toggleButton">▹ <span class="text">Example (Words)</span></p>
  </div>
  <div class="expanded">
    <p class="exampleHeading toggleButton">▾ <span class="text">Example (Words)</span></p>
    <p>Use a Scanner to implement a simple word-count utility by scanning the
input as a sequence of space-delimited tokens.
</p>
    
    
      <div class="play">
        <div class="input"><textarea class="code" spellcheck="false">package main

import (
	&#34;bufio&#34;
	&#34;fmt&#34;
	&#34;os&#34;
	&#34;strings&#34;
)

func main() {
	// An artificial input source.
	const input = &#34;Now is the winter of our discontent,\nMade glorious summer by this sun of York.\n&#34;
	scanner := bufio.NewScanner(strings.NewReader(input))
	// Set the split function for the scanning operation.
	scanner.Split(bufio.ScanWords)
	// Count the words.
	count := 0
	for scanner.Scan() {
		count++
	}
	if err := scanner.Err(); err != nil {
		fmt.Fprintln(os.Stderr, &#34;reading input:&#34;, err)
	}
	fmt.Printf(&#34;%d\n&#34;, count)
}
</textarea></div>
        <div class="output"><pre>15
</pre></div>
        <div class="buttons">
          <button class="Button Button--primary run" title="Run this code [shift-enter]">Run</button>
          <button class="Button fmt" title="Format this code">Format</button>
          
            <button class="Button share" title="Share this code">Share</button>
          
        </div>
      </div>
    
  </div>
</div>


			
				
				<h3 id="NewScanner">func <a href="/src/bufio/scan.go?s=3956:3993#L77">NewScanner</a>
					<a class="permalink" href="#NewScanner">&#xb6;</a>
					
					<span title="Added in Go 1.1">1.1</span>
				</h3>
				<pre>func NewScanner(r <a href="/pkg/io/">io</a>.<a href="/pkg/io/#Reader">Reader</a>) *<a href="#Scanner">Scanner</a></pre>
				<p>
NewScanner returns a new Scanner to read from r.
The split function defaults to ScanLines.
</p>

				
			

			
				
				<h3 id="Scanner.Buffer">func (*Scanner) <a href="/src/bufio/scan.go?s=9226:9271#L257">Buffer</a>
					<a class="permalink" href="#Scanner.Buffer">&#xb6;</a>
					
					<span title="Added in Go 1.6">1.6</span>
				</h3>
				<pre>func (s *<a href="#Scanner">Scanner</a>) Buffer(buf []<a href="/pkg/builtin/#byte">byte</a>, max <a href="/pkg/builtin/#int">int</a>)</pre>
				<p>
Buffer sets the initial buffer to use when scanning and the maximum
size of buffer that may be allocated during scanning. The maximum
token size is the larger of max and cap(buf). If max &lt;= cap(buf),
Scan will use this buffer only and do no allocation.
</p>
<p>
By default, Scan uses an internal buffer and sets the
maximum token size to MaxScanTokenSize.
</p>
<p>
Buffer panics if it is called after scanning has started.
</p>

				
				
			
				
				<h3 id="Scanner.Bytes">func (*Scanner) <a href="/src/bufio/scan.go?s=4454:4486#L96">Bytes</a>
					<a class="permalink" href="#Scanner.Bytes">&#xb6;</a>
					
					<span title="Added in Go 1.1">1.1</span>
				</h3>
				<pre>func (s *<a href="#Scanner">Scanner</a>) Bytes() []<a href="/pkg/builtin/#byte">byte</a></pre>
				<p>
Bytes returns the most recent token generated by a call to Scan.
The underlying array may point to data that will be overwritten
by a subsequent call to Scan. It does no allocation.
</p>

				
				<div id="example_Scanner_Bytes" class="toggle">
  <div class="collapsed">
    <p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
  </div>
  <div class="expanded">
    <p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
    <p>Return the most recent call to Scan as a []byte.
</p>
    
    
      <div class="play">
        <div class="input"><textarea class="code" spellcheck="false">package main

import (
	&#34;bufio&#34;
	&#34;fmt&#34;
	&#34;os&#34;
	&#34;strings&#34;
)

func main() {
	scanner := bufio.NewScanner(strings.NewReader(&#34;gopher&#34;))
	for scanner.Scan() {
		fmt.Println(len(scanner.Bytes()) == 6)
	}
	if err := scanner.Err(); err != nil {
		fmt.Fprintln(os.Stderr, &#34;shouldn&#39;t see an error scanning a string&#34;)
	}
}
</textarea></div>
        <div class="output"><pre>true
</pre></div>
        <div class="buttons">
          <button class="Button Button--primary run" title="Run this code [shift-enter]">Run</button>
          <button class="Button fmt" title="Format this code">Format</button>
          
            <button class="Button share" title="Share this code">Share</button>
          
        </div>
      </div>
    
  </div>
</div>

			
				
				<h3 id="Scanner.Err">func (*Scanner) <a href="/src/bufio/scan.go?s=4176:4205#L86">Err</a>
					<a class="permalink" href="#Scanner.Err">&#xb6;</a>
					
					<span title="Added in Go 1.1">1.1</span>
				</h3>
				<pre>func (s *<a href="#Scanner">Scanner</a>) Err() <a href="/pkg/builtin/#error">error</a></pre>
				<p>
Err returns the first non-EOF error that was encountered by the Scanner.
</p>

				
				
			
				
				<h3 id="Scanner.Scan">func (*Scanner) <a href="/src/bufio/scan.go?s=5803:5832#L125">Scan</a>
					<a class="permalink" href="#Scanner.Scan">&#xb6;</a>
					
					<span title="Added in Go 1.1">1.1</span>
				</h3>
				<pre>func (s *<a href="#Scanner">Scanner</a>) Scan() <a href="/pkg/builtin/#bool">bool</a></pre>
				<p>
Scan advances the Scanner to the next token, which will then be
available through the Bytes or Text method. It returns false when the
scan stops, either by reaching the end of the input or an error.
After Scan returns false, the Err method will return any error that
occurred during scanning, except that if it was io.EOF, Err
will return nil.
Scan panics if the split function returns too many empty
tokens without advancing the input. This is a common error mode for
scanners.
</p>

				
				
			
				
				<h3 id="Scanner.Split">func (*Scanner) <a href="/src/bufio/scan.go?s=9539:9579#L269">Split</a>
					<a class="permalink" href="#Scanner.Split">&#xb6;</a>
					
					<span title="Added in Go 1.1">1.1</span>
				</h3>
				<pre>func (s *<a href="#Scanner">Scanner</a>) Split(split <a href="#SplitFunc">SplitFunc</a>)</pre>
				<p>
Split sets the split function for the Scanner.
The default split function is ScanLines.
</p>
<p>
Split panics if it is called after scanning has started.
</p>

				
				
			
				
				<h3 id="Scanner.Text">func (*Scanner) <a href="/src/bufio/scan.go?s=4624:4655#L102">Text</a>
					<a class="permalink" href="#Scanner.Text">&#xb6;</a>
					
					<span title="Added in Go 1.1">1.1</span>
				</h3>
				<pre>func (s *<a href="#Scanner">Scanner</a>) Text() <a href="/pkg/builtin/#string">string</a></pre>
				<p>
Text returns the most recent token generated by a call to Scan
as a newly allocated string holding its bytes.
</p>

				
				
			
		
			
			
			<h2 id="SplitFunc">type <a href="/src/bufio/scan.go?s=3047:3130#L55">SplitFunc</a>
				<a class="permalink" href="#SplitFunc">&#xb6;</a>
				
				<span title="Added in Go 1.1">1.1</span>
			</h2>
			<p>
SplitFunc is the signature of the split function used to tokenize the
input. The arguments are an initial substring of the remaining unprocessed
data and a flag, atEOF, that reports whether the Reader has no more data
to give. The return values are the number of bytes to advance the input
and the next token to return to the user, if any, plus an error, if any.
</p>
<p>
Scanning stops if the function returns an error, in which case some of
the input may be discarded.
</p>
<p>
Otherwise, the Scanner advances the input. If the token is not nil,
the Scanner returns it to the user. If the token is nil, the
Scanner reads more data and continues scanning; if there is no more
data--if atEOF was true--the Scanner returns. If the data does not
yet hold a complete token, for instance if it has no newline while
scanning lines, a SplitFunc can return (0, nil, nil) to signal the
Scanner to read more data into the slice and try again with a
longer slice starting at the same point in the input.
</p>
<p>
The function is never called with an empty data slice unless atEOF
is true. If atEOF is true, however, data may be non-empty and,
as always, holds unprocessed text.
</p>

			<pre>type SplitFunc func(data []<a href="/pkg/builtin/#byte">byte</a>, atEOF <a href="/pkg/builtin/#bool">bool</a>) (advance <a href="/pkg/builtin/#int">int</a>, token []<a href="/pkg/builtin/#byte">byte</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>

			

			

			

			

			
		
			
			
			<h2 id="Writer">type <a href="/src/bufio/bufio.go?s=14997:15066#L548">Writer</a>
				<a class="permalink" href="#Writer">&#xb6;</a>
				
				
			</h2>
			<p>
Writer implements buffering for an io.Writer object.
If an error occurs writing to a Writer, no more data will be
accepted and all subsequent writes, and Flush, will return the error.
After all data has been written, the client should call the
Flush method to guarantee all data has been forwarded to
the underlying io.Writer.
</p>

			<pre>type Writer struct {
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			<div id="example_Writer" class="toggle">
  <div class="collapsed">
    <p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
  </div>
  <div class="expanded">
    <p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
    
    
    
      <div class="play">
        <div class="input"><textarea class="code" spellcheck="false">package main

import (
	&#34;bufio&#34;
	&#34;fmt&#34;
	&#34;os&#34;
)

func main() {
	w := bufio.NewWriter(os.Stdout)
	fmt.Fprint(w, &#34;Hello, &#34;)
	fmt.Fprint(w, &#34;world!&#34;)
	w.Flush() // Don&#39;t forget to flush!
}
</textarea></div>
        <div class="output"><pre>Hello, world!
</pre></div>
        <div class="buttons">
          <button class="Button Button--primary run" title="Run this code [shift-enter]">Run</button>
          <button class="Button fmt" title="Format this code">Format</button>
          
            <button class="Button share" title="Share this code">Share</button>
          
        </div>
      </div>
    
  </div>
</div>


			
				
				<h3 id="NewWriter">func <a href="/src/bufio/bufio.go?s=15581:15616#L574">NewWriter</a>
					<a class="permalink" href="#NewWriter">&#xb6;</a>
					
					
				</h3>
				<pre>func NewWriter(w <a href="/pkg/io/">io</a>.<a href="/pkg/io/#Writer">Writer</a>) *<a href="#Writer">Writer</a></pre>
				<p>
NewWriter returns a new Writer whose buffer has the default size.
</p>

				
			
				
				<h3 id="NewWriterSize">func <a href="/src/bufio/bufio.go?s=15262:15311#L558">NewWriterSize</a>
					<a class="permalink" href="#NewWriterSize">&#xb6;</a>
					
					
				</h3>
				<pre>func NewWriterSize(w <a href="/pkg/io/">io</a>.<a href="/pkg/io/#Writer">Writer</a>, size <a href="/pkg/builtin/#int">int</a>) *<a href="#Writer">Writer</a></pre>
				<p>
NewWriterSize returns a new Writer whose buffer has at least the specified
size. If the argument io.Writer is already a Writer with large enough
size, it returns the underlying Writer.
</p>

				
			

			
				
				<h3 id="Writer.Available">func (*Writer) <a href="/src/bufio/bufio.go?s=16420:16452#L614">Available</a>
					<a class="permalink" href="#Writer.Available">&#xb6;</a>
					
					
				</h3>
				<pre>func (b *<a href="#Writer">Writer</a>) Available() <a href="/pkg/builtin/#int">int</a></pre>
				<p>
Available returns how many bytes are unused in the buffer.
</p>

				
				
			
				
				<h3 id="Writer.Buffered">func (*Writer) <a href="/src/bufio/bufio.go?s=16570:16601#L617">Buffered</a>
					<a class="permalink" href="#Writer.Buffered">&#xb6;</a>
					
					
				</h3>
				<pre>func (b *<a href="#Writer">Writer</a>) Buffered() <a href="/pkg/builtin/#int">int</a></pre>
				<p>
Buffered returns the number of bytes that have been written into the current buffer.
</p>

				
				
			
				
				<h3 id="Writer.Flush">func (*Writer) <a href="/src/bufio/bufio.go?s=16017:16047#L590">Flush</a>
					<a class="permalink" href="#Writer.Flush">&#xb6;</a>
					
					
				</h3>
				<pre>func (b *<a href="#Writer">Writer</a>) Flush() <a href="/pkg/builtin/#error">error</a></pre>
				<p>
Flush writes any buffered data to the underlying io.Writer.
</p>

				
				
			
				
				<h3 id="Writer.ReadFrom">func (*Writer) <a href="/src/bufio/bufio.go?s=18720:18779#L714">ReadFrom</a>
					<a class="permalink" href="#Writer.ReadFrom">&#xb6;</a>
					
					<span title="Added in Go 1.1">1.1</span>
				</h3>
				<pre>func (b *<a href="#Writer">Writer</a>) ReadFrom(r <a href="/pkg/io/">io</a>.<a href="/pkg/io/#Reader">Reader</a>) (n <a href="/pkg/builtin/#int64">int64</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
ReadFrom implements io.ReaderFrom. If the underlying writer
supports the ReadFrom method, and b has no buffered data yet,
this calls the underlying ReadFrom without buffering.
</p>

				
				
			
				
				<h3 id="Writer.Reset">func (*Writer) <a href="/src/bufio/bufio.go?s=15881:15916#L583">Reset</a>
					<a class="permalink" href="#Writer.Reset">&#xb6;</a>
					
					<span title="Added in Go 1.2">1.2</span>
				</h3>
				<pre>func (b *<a href="#Writer">Writer</a>) Reset(w <a href="/pkg/io/">io</a>.<a href="/pkg/io/#Writer">Writer</a>)</pre>
				<p>
Reset discards any unflushed buffered data, clears any error, and
resets b to write its output to w.
</p>

				
				
			
				
				<h3 id="Writer.Size">func (*Writer) <a href="/src/bufio/bufio.go?s=15723:15750#L579">Size</a>
					<a class="permalink" href="#Writer.Size">&#xb6;</a>
					
					<span title="Added in Go 1.10">1.10</span>
				</h3>
				<pre>func (b *<a href="#Writer">Writer</a>) Size() <a href="/pkg/builtin/#int">int</a></pre>
				<p>
Size returns the size of the underlying buffer in bytes.
</p>

				
				
			
				
				<h3 id="Writer.Write">func (*Writer) <a href="/src/bufio/bufio.go?s=16794:16846#L623">Write</a>
					<a class="permalink" href="#Writer.Write">&#xb6;</a>
					
					
				</h3>
				<pre>func (b *<a href="#Writer">Writer</a>) Write(p []<a href="/pkg/builtin/#byte">byte</a>) (nn <a href="/pkg/builtin/#int">int</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
Write writes the contents of p into the buffer.
It returns the number of bytes written.
If nn &lt; len(p), it also returns an error explaining
why the write is short.
</p>

				
				
			
				
				<h3 id="Writer.WriteByte">func (*Writer) <a href="/src/bufio/bufio.go?s=17270:17310#L648">WriteByte</a>
					<a class="permalink" href="#Writer.WriteByte">&#xb6;</a>
					
					
				</h3>
				<pre>func (b *<a href="#Writer">Writer</a>) WriteByte(c <a href="/pkg/builtin/#byte">byte</a>) <a href="/pkg/builtin/#error">error</a></pre>
				<p>
WriteByte writes a single byte.
</p>

				
				
			
				
				<h3 id="Writer.WriteRune">func (*Writer) <a href="/src/bufio/bufio.go?s=17556:17612#L662">WriteRune</a>
					<a class="permalink" href="#Writer.WriteRune">&#xb6;</a>
					
					
				</h3>
				<pre>func (b *<a href="#Writer">Writer</a>) WriteRune(r <a href="/pkg/builtin/#rune">rune</a>) (size <a href="/pkg/builtin/#int">int</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
WriteRune writes a single Unicode code point, returning
the number of bytes written and any error.
</p>

				
				
			
				
				<h3 id="Writer.WriteString">func (*Writer) <a href="/src/bufio/bufio.go?s=18244:18295#L693">WriteString</a>
					<a class="permalink" href="#Writer.WriteString">&#xb6;</a>
					
					
				</h3>
				<pre>func (b *<a href="#Writer">Writer</a>) WriteString(s <a href="/pkg/builtin/#string">string</a>) (<a href="/pkg/builtin/#int">int</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
WriteString writes a string.
It returns the number of bytes written.
If the count is less than len(s), it also returns an error explaining
why the write is short.
</p>

				
				
			
		
	

	







</div><!-- .container -->
</main><!-- #page -->
<footer>
  <div class="Footer Footer--wide">
    <img class="Footer-gopher" src="/lib/godoc/images/footer-gopher.jpg" alt="The Go Gopher">
    <ul class="Footer-links">
      <li class="Footer-link"><a href="/doc/copyright.html">Copyright</a></li>
      <li class="Footer-link"><a href="/doc/tos.html">Terms of Service</a></li>
      <li class="Footer-link"><a href="http://www.google.com/intl/en/policies/privacy/">Privacy Policy</a></li>
      <li class="Footer-link"><a href="http://golang.org/issues/new?title=x/website:" target="_blank" rel="noopener">Report a website issue</a></li>
    </ul>
    <a class="Footer-supportedBy" href="https://google.com">Supported by Google</a>
  </div>
</footer>

<script>
(function() {
  var ga = document.createElement("script"); ga.type = "text/javascript"; ga.async = true;
  ga.src = ("https:" == document.location.protocol ? "https://ssl" : "http://www") + ".google-analytics.com/ga.js";
  var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(ga, s);
})();
</script>
